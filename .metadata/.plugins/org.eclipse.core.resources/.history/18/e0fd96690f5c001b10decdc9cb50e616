import org.sat4j.core.VecInt;
import java.util.ArrayList;
import org.sat4j.minisat.SolverFactory;
import org.sat4j.specs.ISolver;
import org.sat4j.specs.ContradictionException;
import org.sat4j.specs.TimeoutException;


public class SAT {

	public static void solveSAT(ArrayList<ArrayList<Integer>> graph){
		// Takes as input a graph represented by its adjacency matrix
		int n = graph.size();
		
		// Create the solver 
				ISolver solver = SolverFactory.newDefault();
				// Convert the Hamiltonian path problem to a CNF
				// Then feed the solver using arrays of int in Dimacs format
				// Boolean x_ij (node j in position i) is represented by the integer i*n + j
				try {
					// Each node j must appear in the path :
					for (int j = 1; j < n+1; j++) {
						VecInt v = new VecInt();
						for (int i = 1; i < n+1; i++) {
							v.insertFirst(i*n + j);
						}
						solver.addClause(v);
					}
					
					// No node j appears twice in the path
					for (int j = 1; j < n+1; j++) {
						for (int i = 1; i < n+1; i++) {
							for (int k = 1; k < n+1; k++) {
								if (i != k) {
									VecInt v = new VecInt();
									v.insertFirst(-(i*n + j));;
									v.insertFirst(-(k*n + j));;
									solver.addClause(v);
								}
							}
						}
					}
					
					// Every position i on the path must be occupied 
					for (int i = 1; i < n+1; i++) {
						VecInt v = new VecInt();
						for (int j = 1; j < n+1; j++) {
							v.insertFirst(i*n + j);;
						}
						solver.addClause(v);
					}
					
					// No two nodes j and k occupy the same position
					for (int i = 1; i < n+1; i++) {
						for (int j = 1; j < n+1; j++) {
							for (int k = 1; k < n+1; k++) {
								if (j != k) {
									VecInt v = new VecInt();
									v.insertFirst(-(i*n + j));;
									v.insertFirst(-(i*n + k));;
									solver.addClause(v);
								}
							}
						}
					}
					
					// Nonadjacent nodes i and j cannot be adjacent in the path
					fpr (int k = 0; )
					
				} catch (ContradictionException e1) {
					e1.printStackTrace();
				}
				// Print parameters of the problem
				System.out.println("Number of variables: " + solver.nVars());
				System.out.println("Number of constraints: " + solver.nConstraints());
				// Solve the problem
				try {
					if (solver.isSatisfiable()) {
						System.out.println("Satisfiable problem!");
						int[] solution = solver.model();
						System.out.println("Solution: " + solution[0] + " " + solution[1]);
					} else {
						System.out.println("Unsatisfiable problem!");
					}
				} catch (TimeoutException e) {
					System.out.println("Timeout, sorry!");
				}
			}

		public static void main(String[] args) {
			
		}
	}